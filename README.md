
## Tips and Tricks

### "Масштабирование" интерфейса

#### ❌

Если устанавливать размеры элементов статичными единицами измерения, то их придется менять позже на брейкпоинте

```css
span {
    font-size: 16px;
    margin: 16rem 32rem;
}

@media screen and (max-width: 768px) {
    span {
        font-size: 14px;
        margin: 14rem 28rem;
    }
}
```

#### ✔️

Если использовать REM 

```css
html {
    font-size: 62.5%;
    /* 16*0.625 = 10px */
    /* Соответственно 1rem => 10px */
}

body {
    font-size: 1.6rem;
    /* Возвращаем стандартный размер шрифта - 16px */
}

span {
    font-size: 1.6rem;
    margin: 1.6rem 3.2rem;
}

@media screen and (max-width: 768px) {
    html {
        font-size: 56.25%;
        /* 16*0.5625 = 9px */
        /* Уменьшаем интерфейс когда доходим до брейкпоинта */
    }
}
```

> [!CAUTION]
> REM хак может быть удобен, однако иногда его применение ломает логику дизайна (например, когда вам приходится переписывать интерфейс на мобильном устройстве) и у вас будет 2 выхода:
> - Пересчитывать вручную все размеры с макета с тем `font-size` html'я, который у вас окажется на брейкпоинте экрана
> - Поднимать обратно `font-size` до 62.5%

> [!CAUTION]
> Если с вас требуется pixel perfect дизайн на определенном вьюпорте, вы не используете никакие UI-киты, а адаптивная верстка просто должна работать, то это суперски сэкономит время и силы. Если вам необходимо придерживаться логики "доступность > как в макете", то это метод проб и ошибок (неплохая [статья](https://www.joshwcomeau.com/css/surprising-truth-about-pixels-and-accessibility/) про это)

_В рамках нашей дисциплины вы можете использовать любой подход (кроме пикселей везде), так как мы будем придерживаться доступности до тех пор, пока не будет мешать повторению макета. В частности это задание будет требовать от вас использование REM везде, кроме `@media` запросов_

### Логические свойства

#### ❌

`margin: 0 auto` является нелогическим свойством, которое всегда понимает лево-право относительно вьюпорта, а не элемента

#### ✔️

`margin-inline: auto` является логическим свойством, которое всегда применяет отступ относительно элемента

### Overflow контейнера по вертикали

#### ❌

`height: 100vh` - если контента будет больше, чем на один экран, то он будет отрезаться по контейнеру

#### ✔️

`max-height: 100vh` - если контента будет больше, чем на один экран, то он увеличивать высоту контейнера

### Overflow контейнера по горизонтали

#### ❌

`width: 144rem` - при достижении этой ширины придется писать медиа селектор на `width: 100%`

#### ✔️

`max-width: 144rem` - при достижении этой ширины контейнер автоматически станет занимать всю ширину родителя (window)

### Двойственность viewport единиц измерения на мобильных устройствах

Наличие "авто скрываемой" навигации в браузере заставляет обычные vh единицы измерения работать по-разному в разных браузерах

<img width="100%" src=".repo/vh.png" />

`dvh` не является решением всех проблем, так как при скролле меню скроется, а высота контейнера вырастет - элементы будут прыгать

_Поэтому чаще всего приходится решать в зависимости от ситуации и ТЗ_

# Интересное

- [Статистика вьюпортов](https://gs.statcounter.com/screen-resolution-stats)